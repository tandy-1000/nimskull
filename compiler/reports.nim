## This module provides type definitions for all structured report entries
## that compiler can provide.
##
## Note that this module specifically does not import anything else from
## the compiler - by design it is supposed to be available in every other
## module (because almost any phase of the compiler can generate reports
## one way or another). By design report should contain as much information
## as possible and *never* be used for any conditional logic in the
## compiler - it is a final form of the output that can only be printed to
## the output (either via user-provided report hook implementation, or
## using one of the built-in ones)
##
## Not using compiler-specific types also allows this report to be easily
## reused by external tooling - custom error pretty-printers, test runners
## and so on.

import std/[options, packedsets]

import
  ast_types,
  vm_enums,
  nilcheck_enums,
  int128,
  platform

export
  ast_types,
  options.some,
  options.none,
  options.Option,
  int128.toInt128

type InstantiationInfo* = typeof(instantiationInfo())


type
  ReportCategory* = enum
    ## Kinds of the toplevel reports. Only dispatches on report topics,
    ## such as sem, parse, macro (for `echo` in compile-time code) and so
    ## on. Subdivision is based on different phases of the compiler
    ## operation, and not on report's state itself, as those are completely
    ## orthogonal to each other (lexer might provide errors and hints,
    ## parser can provide errors, hints and warnings)

    repParser = "Parser"
    repLexer = "Lexer" ## Report generated by lexer - bad tokens, lines
    ## that are too long etc.

    repSem = "Sem" ## Report produced directly by semantic analysis -
    ## compilation errors, warnings and hints

    repCmd = "Cmd" ## Report related to execution of the external command -
    ## start of the command, execution failure, succes and so on.

    repDebug = "Debug" ## Side channel for the compiler debug report. Sem
    ## expansion traces and other helper messages designed specifically to
    ## aid development of the compiler

    repInternal = "Internal" ## Reports constructed during hanling of the
    ## internal compilation errors. Separate from debugging reports since
    ## they always exist - ICE, internal fatal errors etc.

    repBackend = "Backend" ## Backend-specific reports.

    repExternal = "External" ## Report constructed during handling of the
    ## external configuration, command-line flags, packages, modules.


  ReportKind* = enum
    ## Toplevel enum for different categories. Order of definitions is
    ## really important - elements are first separated into categories
    ## (internal reports, backend reports and so on) and can be further
    ## split into severity levels.
    ##
    ## Different naming scheme is used for a reports with different
    ## categories - this enum exists only to make it easier to work with
    ## different report kinds, without having to manage seven different
    ## enum types.

    repNone

    #--------------------------  Internal reports  ---------------------------#
    # Internal reports being
    # fatal errors begin
    rintUnknown ## Unknown internal report kind
    rintFatal ## Explicitly fatal compiler error

    rintUnreachable ## State in the compiler code that must not be reached
    rintAssert ## Failed internal assert in the compiler


    rintIce ## Internal compilation error
    # fatal end

    # errors being
    rintCannotOpenFile
    rintUsingLeanCompiler
    rintNotUsingNimcore
    rintNotImplemented
    # errors end

    # warnings begin
    rintWarnCannotOpenFile
    rintUnexpected
    rintWarnFileChanged
    # warnings end

    # hints start
    rintSource = "Source" ## Show source in the report
                          # REFACTOR this is a global configuration option,
                          # not a hint.


    rintGCStats = "GCStats" ## Print GC statistics for the compiler run
    rintQuitCalled = "QuitCalled" ## `quit()` called by the macro code
    ## compilation error handling and similar
    rintMissingStackTrace ## Stack trace would've been generated in the
    ## debug compiler build
    rintMsgOrigin = "MsgOrigin"
    rintErrKind = "ErrKind" ## Show report kind in error messages

    rintSuccessX = "SuccessX" ## Succesfull compilation
    # hints end

    rintStackTrace = "StackTrace" ## Stack trace during internal
    rintNimconfWrite
    rintListWarnings
    rintListHints

    rintCliHelp # cli report first!
    rintCliFullHelp
    rintCliVersion
    rintCliAdvancedUsage # cli report last!

    rintDumpState
    rintEchoMessage # last !

    # internal reports end

    #--------------------------  External reports  ---------------------------#
    # External reports
    # errors begin
    rextUnknownCCompiler

    # malformed cmdline parameters begin
    rextInvalidHint
    rextInvalidWarning
    rextInvalidCommandLineOption ## Invalid command-line option passed to
                                 ## the compiler
    rextOnlyAllOffSupported ## Only `all:off` is supported for mass
    ## hint/warning modification. Separate diagnostics must be enabled on
    ## one-by-one basis.
    rextExpectedOnOrOff ## Command-line option expected 'on' or 'off' value
    rextExpectedOnOrOffOrList ## Command-line option expected 'on', 'off'
    ## or 'list' value.
    rextExpectedCmdArgument ## Command-line option expected argument
    rextExpectedNoCmdArgument ## Command-line option expected no arguments
    rextInvalidNumber ## Command-line switch expected a number
    rextInvalidValue
    rextUnexpectedValue ## Command-line argument had value, but it did not
    ## match with any expected.

    rextIcUnknownFileName
    rextIcNoSymbolAtPosition

    rextExpectedCbackendForRun
    rextExpectedTinyCForRun
    rextInvalidCommand
    rextCommandMissing
    rextExpectedRunOptForArgs
    rextUnexpectedRunOpt
    rextInvalidPath ## Invalid path for a command-line argument

    rextInvalidPackageName ## When adding packages from the `--nimbleDir`
    ## (or it's default value), names are validated. This error is
    ## generated if package name is not correct.
    # errors end

    # warnings begin
    rextDeprecated ## Report about use of the deprecated feature that is
    ## not in the semantic pass. Things like deprecated flags, compiler
    ## commands and so on.
    # warnings end

    # hints start
    rextConf = "Conf" ## Processing user configutation file
    rextPath = "Path" ## Add nimble path
    # hints end

    # external reports end

    #----------------------------  Lexer reports  ----------------------------#
    # Lexer report begin
    # errors begin
    rlexMalformedUnderscores
    rlexMalformedTrailingUnderscre
    rlexInvalidToken
    rlexNoTabs

    # numbers
    rlexInvalidIntegerPrefix
    rlexInvalidIntegerSuffix
    rlexNumberNotInRange
    rlexExpectedHex
    rlexInvalidIntegerLiteral

    # char
    rlexInvalidCharLiteral
    rlexMissingClosingApostrophe
    rlexInvalidUnicodeCodepoint

    # string
    rlexUnclosedTripleString
    rlexUnclosedSingleString

    rlexExpectedToken
    rlexCfgInvalidDirective

    # comments
    rlexUnclosedComment

    # errors end

    # warnings begin
    rlexDeprecatedOctalPrefix = "OctalEscape"
    # warnings end

    # hints begin
    rlexLineTooLong = "LineTooLong"
    rlexLinterReport = "Name"

    rlexSyntaxesCode
    # hints end

    # Lexer report end

    #---------------------------  Parser reports  ----------------------------#
    # errors begin
    # regular nim parser
    rparInvalidIndentation
    rparNestableRequiresIndentation

    rparIdentExpected
    rparIdentOrKwdExpected
    rparExprExpected
    rparMissingToken
    rparUnexpectedToken
    rparUnexpectedTokenKind

    rparFuncNotAllowed
    rparTupleTypeWithPar
    rparMisplacedParameterVar
    rparConceptNotinType
    rparRotineExpected
    rparPragmaAlreadyPresent
    rparMisplacedExport

    # template parser `filter_tmpl.nim`
    rparTemplMissingEndClose
    rparTemplInvalidExpression

    rparInvalidFilter

    # erorrs end

    # warnings begin
    rparInconsistentSpacing = "Spacing"
    rparEnablePreviewDotOps = "DotLikeOps"
    rparPragmaNotFollowingTypeName
    rparPragmaBeforeGenericParameters
    # warnings end

    rparName = "Name" ## Linter report about used identifier

    #-----------------------------  Sem reports  -----------------------------#
    # semantic fatal
    rsemFatalError
    # end

    # Semantic errors begin
    rsemUserError = "UserError" ## `{.error: }`
    rsemUsageIsError

    rsemCompilesError

    rsemCustomError
    rsemCustomPrintMsgAndNodeError
      ## just like custom error, prints a message and renders wrongNode
    rsemTypeMismatch
    rsemTypeKindMismatch
    rsemAmbiguous
    rsemAmbiguousIdent

    rsemCustomUserError
      ## just like customer error, but reported as a errUser in msgs

    rsemNodeNotAllowed
      ## Generated in `filters.nim`

    rsemCannotProveNotNil
    rsemProvablyNil

    # nimsuggest
    rsemSugNoSymbolAtPosition

    # Global Errors
    rsemCustomGlobalError
      ## just like custom error, but treat it like a "raise" and fast track the
      ## "graceful" abort of this compilation run, used by `errorreporting` to
      ## bridge into the existing `msgs.liMessage` and `msgs.handleError`.

    # Module errors
    rsemSystemNeeds
    rsemInvalidModulePath
    rsemInvalidModuleName
    rsemCannotImportItself
    rsemRecursiveInclude
    rsemRecursiveImport
    rsemCannotOpenFile
    rsemExportRequiresToplevel
    rsemExperimentalRequiresToplevel
    rsemMethodRequiresToplevel
    rsemPackageRequiresToplevel
    rsemConverterRequiresToplevel
    rsemImportRequiresToplevel
    rsemUnexpectedToplevelDefer
    rsemUsingRequiresToplevel
    rsemInvalidVisibility
    rsemUnknownPackageName
    rsemUnexpectedInfixInInclude

    # ..
    rsemConflictingExportnims
    rsemNoMagicEqualsForType
    rsemCantConvertLiteralToType
    rsemCantConvertLiteralToRange
    rsemCantComputeOffsetof
    rsemStaticOutOfBounds ## Error generated when semfold or static bound
    ## checking sees and out-of-bounds index error.
    rsemStaticFieldNotFound # TODO DOC generated in `semfold.nim`, need
    # better documentation, right now I don't know what exactly this error
    # means and how to reproduce it in the example code.
    rsemSemfoldOverflow
    rsemSemfoldDivByZero
    rsemSemfoldInvalidConversion
    rsemInvalidIntdefine
    rsemInvalidBooldefine


    # Type definitions
    rsemCaseInUnion ## `{.union.}` type cannot use `case:` statements
    rsemOffsetInUnion ## `{.union.}` type cannot use inheritance and any
    ## other features that add implicit chunk of data before the actually
    ## listed fields.
    rsemUnexpectedInNewConcept
    rsemTooNestedConcept
    rsemIllegalRecursion
    rsemCannotInferStaticValue

    rsemVarVarNotAllowed ## `var lent`, `var var` etc. are not allowed in
    ## types
    rsemInvalidOrderInEnum
    rsemSetTooBig
    rsemTIsNotAConcreteType
    rsemProcIsNotAConcreteType
    rsemRangeIsEmpty

    rsemCannotInstantiate
    rsemCannotInstantiateWithParameter
    rsemCannotGenerateGenericDestructor
    rsemUndeclaredField
    rsemInheritanceOnlyWorksWithAnEnum # I have **//ABSOLUTELY NO IDEA//**
    # what this error means. I think I might need to add something like
    # `rsemWTF`
    rsemExpectedOrdinal
    rsemExpectedOrdinalOrFloat
    rsemExpectedUnholyEnum # yes
    rsemExpectedLow0Discriminant
    rsemExpectedHighCappedDiscriminant
    rsemMissingCaseBranches
    rsemRangeDoesNotSupportNan
    rsemRangeRequiresDotDot
    rsemExpectedRange
    rsemArrayExpectsPositiveRange
    rsemExpectObjectForBase
    rsemExpectNonFinalForBase

    rsemTVoidNotAllowed
    rsemExpectedObjectForRegion
    rsemUnexpectedVoidType
    rsemUnexpectedArrayAssignForCstring
    rsemMacroBodyDependsOnGenericTypes
    rsemMalformedNotNilType
    rsemEnableNotNilExperimental
    rsemEnableDotOperatorsExperimental
    rsemEnableCallOperatorExperimental
    rsemExpectedObjectType
    rsemExpectedImportedType
    rsemUnexpectedExportcInAlias
    rsemExpectedDistinctForBorrow
    rsemBorrowTargetNotFound
    rsemConceptInferenceFailed
    rsemConceptPredicateFailed

    # Procedure definition and instantiation
    rsemImplementationNotAllowed
    rsemImplementationExpected
    rsemRedefinitionOf
    rsemDefaultParamIsIncompatible
    rsemDeclarationVisibilityMismatch
    rsemGenericLambdaNowAllowed
    rsemUnexpectedAutoInForwardDeclaration
    rsemUnexpectedClosureOnToplevelProc
    rsemExpectedReturnTypeForIterator
    rsemExpectedReturnTypeForConverter
    rsemExpectedOneArgumentForConverter
    rsemIncompatibleDefaultExpr

    # Call and procedures
    rsemCallTypeMismatch
    rsemCallIndirectTypeMismatch
    rsemCallNotAProcOrField ## unknown or semantically invalid `obj.field`,
    ## `obj.call()`
    rsemExpressionCannotBeCalled
    rsemWrongNumberOfArguments
    rsemWrongNumberOfVariables
    rsemWrongNumberOfGenericParams
    rsemNoGenericParamsAllowed
    rsemAmbiguousCall
    rsemCallingConventionMismatch
    rsemHasSideEffects
    rsemCantPassProcvar
    rsemUnlistedRaises
    rsemUnlistedEffects
    rsemOverrideSafetyMismatch
    rsemOverrideLockMismatch
    rsemMissingMethodDispatcher
    rsemNotABaseMethod
    rsemIllegalCallconvCapture
    rsemIllegalMemoryCapture
    rsemIgnoreInvalidForLoop
    rsemMissingGenericParamsForTemplate
    rsemMisplacedMagicType
    rsemCannotInferParameterType
    rsemParameterRequiresAType
    rsemParameterRedefinition
    rsemInvalidExpression
    rsemExpectedNonemptyPattern

    rsemTemplateInstantiationTooNested
    rsemMacroInstantiationTooNested
    rsemGenericInstantiationTooNested # TODO write out list of generic,
    # macro or template instantiations. There is a `pushOwner` called for
    # each generic instantiation - can this be reused?

    rsemCannotSpawnProcWithVar
    rsemCannotSpawnMagicProc
    rsemCannotDiscardSpawn
    rsemSpawnRequiresCall
    rsemSpawnRequiresGcSafe
    rsemSpawnForbidsClosure
    rsemSpawnForbidsIterator

    rsemInvalidMethodDeclarationOrder # Right now I have no idea what this
    # error means exactly. It /does/ have a 'sort of' reproducible example
    # - https://github.com/nim-lang/Nim/issues/5325. No real tests for this
    # one of course, I mean who needs this, right?
    rsemIsNotParameterOf
    rsemParameterNotPointerToPartial

    # Statements
    rsemDiscardingVoid
    rsemDiscardingProc
    rsemInvalidControlFlow
    rsemContinueCannotHaveLabel
    rsemUseOrDiscard
    rsemUseOrDiscardExpr
    rsemCannotBeRaised
    rsemCannotRaiseNonException
    rsemExceptionAlreadyHandled
    rsemCannotExceptNativeAndImported
    rsemExpectedSingleFinally
    rsemExpectedSingleGeneralExcept
    rsemCannotConvertToRange
    rsemUsingRequiresType
    rsemUsingDisallowsAssign
    rsemDifferentTypeForReintroducedSymbol
    rsemImplicitFieldConstructinoRequiresPartial
    rsemCannotInferTypeOfLiteral
    rsemCannotInferTypeOfParameter
    rsemProcHasNoConcreteType
    rsemThreadvarCannotInit
    rsemLetNeedsInit
    rsemConstExpressionExpected
    rsemFieldsIteratorCannotContinue
    rsemParallelFieldsDisallowsCase
    rsemNoObjectOrTupleType
    rsemForExpectsIterator
    rsemSelectorMustBeOfCertainTypes
    rsemTypeCannotBeForwarded
    rsemDoubleCompletionOf
    rsemExpectedInvariantParam
    rsemCovariantUsedAsNonCovariant
    rsemContravariantUsedAsNonCovariant
    rsemNonInvariantCannotBeUsedWith
    rsemNonInvariantCnnnotBeUsedInConcepts
    rsemIncorrectResultProcSymbol
    rsemRebidingImplicitDestructor
    rsemRebidingDestructor
    rsemRebidingDeepCopy
    rsemInseparableTypeBoundOp
    rsemUnexpectedTypeBoundOpSignature
    rsemExpectedDestroyOrDeepCopyForOverride
    rsemExpectedObjectForMethod
    rsemUnexpectedPragmaInDefinitionOf
    rsemMisplacedRunnableExample

    # Expressions
    rsemConstantOfTypeHasNoValue
    rsemTypeConversionArgumentMismatch
    rsemUnexpectedEqInObjectConstructor
    rsemIllegalConversion
    rsemCannotBeConvertedTo
    rsemCannotCastToNonConcrete
    rsemCannotCastTypes
    rsemExpectedTypeOrValue
    rsemInvalidArgumentFor
    rsemNoTupleTypeForConstructor
    rsemInvalidTupleConstructor
    rsemUnknownIdentifier
    rsemIndexOutOfBounds
    rsemInvalidOrderInArrayConstructor
    rsemVarForOutParamNeeded
    rsemStackEscape
    rsemExprHasNoAddress
    rsemUnknownTrait
    rsemStringOrIdentNodeExpected
    rsemExpectedObjectForOf
    rsemCannotBeOfSubtype
    rsemQuantifierInRangeExpected
    rsemOldTakesParameterName
    rsemOldDoesNotBelongTo
    rsemCannotFindPlugin
    rsemExpectedProcReferenceForFinalizer
    rsemCannotIsolate
    rsemCannotInterpretNode
    rsemRecursiveDependencyIterator
    rsemIllegalNimvmContext
    rsemDisallowedNilDeref
    rsemInvalidTupleSubscript
    rsemLocalEscapesStackFrame
    rsemImplicitAddrIsNotFirstParam
    rsemExpectedOwnerReturn
    rsemExpectedUnownedRef
    rsemCannotAssignTo
    rsemNoReturnTypeDeclared
    rsemReturnNotAllowed
    rsemCannotInferReturnType
    rsemExpectedValueForYield
    rsemUnexpectedYield
    rsemCannotReturnTypeless
    rsemExpectedMacroOrTemplate
    rsemAmbiguousGetAst
    rsemExpectedTemplateWithNArgs
    rsemExpectedCallForGetAst
    rsemWrongNumberOfQuoteArguments
    rsemEnableExperimentalParallel
    rsemExpectedExpressionForSpawn
    rsemNamedExprExpected
    rsemNamedExprNotAllowed
    rsemFieldInitTwice
    rsemDisallowedTypedescForTupleField
    rsemDisjointFields
    rsemUnsafeRuntimeDiscriminantInit
    rsemConflictingDiscriminantInit
    rsemConflictingDiscriminantValues
    rsemRuntimeDiscriminantInitCap
    rsemRuntimeDiscriminantMustBeImmutable
    rsemRuntimeDiscriminantRequiresElif
    rsemObjectRequiresFieldInit
    rsemObjectRequiresFieldInitNoDefault
    rsemDistinctDoesNotHaveDefaultValue
    rsemExpectedModuleNameForImportExcept
    rsemCannotExport
    rsemCannotMixTypesAndValuesInTuple
    rsemExpectedTypelessDeferBody
    rsemInvalidBindContext
    rsemCannotCreateImplicitOpenarray
    rsemCannotAssignToDiscriminantWithCustomDestructor
    rsemUnavailableTypeBound

    rsemParallelInvalidControlFlow
    rsemParallelCannotProveDisjoint
    rsemParallelCounterAfterIncrement
    rsemParallelWithoutSpawn
    rsemSpawnInvalidContext

    # Identifier Lookup
    rsemUndeclaredIdentifier
    rsemExpectedIdentifier
    rsemExpectedIdentifierInExpr

    # Object and Object Construction
    rsemFieldNotAccessible
      ## object field is not accessible
    rsemFieldAssignmentInvalid
      ## object field assignment invalid syntax
    rsemFieldOkButAssignedValueInvalid
      ## object field assignment, where the field name is ok, but value is not
    rsemObjectConstructorIncorrect
      ## one or more issues encountered with object constructor

    # General Type Checks
    rsemExpressionHasNoType
      ## an expression has not type or is ambiguous

    rsemRawTypeMismatch

    rsemCannotConvertTypes
    rsemUnresolvedGenericParameter
    rsemCannotCreateFlowVarOfType
    rsemTypeNotAllowed

    # Literals
    rsemIntLiteralExpected
      ## int literal node was expected, but got something else
    rsemStringLiteralExpected
      ## string literal node was expected, but got something else

    rsemOnOrOffExpected
    rsemCallconvExpected
    rsemInnerCodeReordering
    rsemUnknownExperimental
    rsemDuplicateCaseLabel

    # view types
    rsemExpressionIsNotAPath
    rsemResultMustBorrowFirst
    rsemCannotDetermineBorrowTarget # TODO DOC need better explanation for
    # reasons of this error, right now it looks like a hacked-in check.
    rsemCannotBorrow
    rsemBorrowOutlivesSource
    rsemImmutableBorrowMutation

    # VM
    rsemVmOpcParseExpectedExpression
    rsemTooManyRegistersRequired
    rsemVmCannotFindBreakTarget
    rsemVmNotUnused
    rsemNotAFieldSymbol
    rsemVmTooLargetOffset
    rsemVmUnhandledException
    rsemVmCannotGenerateCode
    rsemVmCannotCast
    rsemVmGlobalError ## Error report that was declared as 'global' in the
    ## VM - with current 'globalError-is-a-control-flow-mechanism' approach
    ## this report is largely meaningless, and used only to raise exception.
    rsemVmInvalidBindSym
    rsemVmBadExpandToAst
    rsemVmCannotEvaluateAtComptime
    rsemVmCannotImportc
    rsemVmEnableFFIToImportc
    rsemVmCannotCreateNullElement
    rsemVmInvalidObjectConstructor
    rsemVmNoClosureIterators
    rsemVmCannotCallMethod
    rsemVmCallingNonRoutine
    rsemVmCannotModifyTypechecked
    rsemVmNilAccess
    rsemVmDerefUnsupportedPtr
    rsemVmErrInternal
    rsemVmIndexError
    rsemVmOutOfRange
    rsemVmOverOrUnderflow
    rsemVmDivisionByConstZero
    rsemVmNodeNotASymbol
    rsemVmNodeNotAProcSymbol
    rsemVmNodeNotAFieldSymbol
    rsemVmIllegalConv
    rsemVmMissingCacheKey
    rsemVmCacheKeyAlreadyExists
    rsemVmFieldNotFound
    rsemVmFieldInavailable
    rsemVmCannotSetChild
    rsemVmCannotAddChild
    rsemVmCannotGetChild
    rsemVmNoType
    rsemVmNotAField

    rsemVmTooManyIterations

    rsemMissingImportcCompleteStruct

    rsemCyclicTree
    rsemCyclicDependency
    rsemConstExprExpected

    # Codegen
    rsemRttiRequestForIncompleteObject
    rsemExpectedNimcallProc
    rsemExpectedExhaustiveCaseForComputedGoto
    rsemExpectedUnholyEnumForComputedGoto
    rsemTooManyEntriesForComputedGoto
    rsemExpectedLow0ForComputedGoto
    rsemExpectedCaseForComputedGoto
    rsemDisallowedRangeForComputedGoto
    rsemExpectedCallForCxxPattern
    rsemExpectedParameterForCxxPattern
    rsemExpectedLiteralForGoto
    rsemRequiresDeepCopyEnabled
    rsemDisallowedOfForPureObjects
    rsemDisallowedReprForNewruntime
    rsemCannotCodegenCompiletimeProc

    # Pragma
    rsemInvalidPragma
      ## suplied pragma is invalid
    rsemCannotAttachPragma
    rsemUnexpectedPragma
    rsemPropositionExpected
    rsemIllegalCustomPragma
      ## supplied pragma is not a legal custom pragma, and cannot be attached
    rsemNoReturnHasReturn
      ## a routine marked as no return, has a return type
    rsemImplicitPragmaError
      ## a symbol encountered an error when processing implicit pragmas, this
      ## should be applied to symbols and treated as a wrapper for the purposes
      ## of reporting. the original symbol is stored as the first argument
    rsemPragmaDynlibRequiresExportc
      ## much the same as `ImplicitPragmaError`, except it's a special case
      ## where dynlib pragma requires an importc pragma to exist on the same
      ## symbol
      ## xxx: pragmas shouldn't require each other, that's just bad design

    rsemWrappedError
      ## there is no meaningful error to construct, but there is an error
      ## further down the AST that invalidates the whole

    rsemSymbolKindMismatch
    rsemIllformedAst
    rsemInitHereNotAllowed
    rsemIdentExpectedInExpr
    rsemTypeExpected
    rsemGenericTypeExpected
    rsemTypeInvalid
    rsemWrongIdent
    rsemPragmaOptionExpected
    rsemUnexpectedPushArgument
    rsemCannotPushCast
    rsemCastRequiresStatement
    rsemExportcppRequiresCpp
    rsemDynlibRequiresExportc
    rsemImportjsRequiresJs
    rsemImportjsRequiresPattern
    rsemBitsizeRequires1248
    rsemBitsizeRequiresPositive
    rsemAlignRequiresPowerOfTwo
    rsemPragmaRecursiveDependency
    rsemMisplacedDeprecation
    rsemNoUnionForJs

    rsemThisPragmaRequires01Args
    rsemMismatchedPopPush
    rsemExcessiveCompilePragmaArgs
    rsemLinePragmaExpectsTuple
    rsemRaisesPragmaExpectsObject

    # -- locking
    rsemLocksPragmaExpectsList
    rsemLocksPragmaBadLevel
    rsemLocksRequiresArgs
    rsemMultilockRequiresSameLevel
    rsemInvalidNestedLocking
    rsemUnguardedAccess
    rsemInvalidGuardField

    rsemDrNimRequiresUsesMissingResult
    rsemDrnimCannotProveLeq
    rsemDrnimCannotPorveGe

    rsemErrGcUnsafeListing
    rsemBorrowPragmaNonDot
    rsemInvalidExtern
    rsemInvalidPragmaBlock
    rsemBadDeprecatedArgs
    rsemMisplacedEffectsOf
    rsemMissingPragmaArg
    rsemErrGcUnsafe
    rsemEmptyAsm


    # end

    # Semantic warnings begin
    rsemUserWarning            = "User" ## `{.warning: }`
    rsemUnknownMagic           = "UnknownMagic"
    rsemUnusedImport           = "UnusedImport"
    rsemDeprecated             = "Deprecated"
    rsemLockLevelMismatch      = "LockLevel"
    rsemTypelessParam          = "TypelessParam"

    rsemWarnUnlistedRaises = "Effect" ## `sempass2.checkRaisesSpec` had
    ## `emitWarnings: bool` parameter which was supposedly used to control
    ## whether `strictEffects` warnings actually generated an error, or
    ## just a warning. But all four uses of this proc had constant `false`
    ## written to this field, so for now it does not mean anything and all
    ## mismatched raises are routed as errors.

    rsemDotForModuleImport
    rsemReorderingFail
    rsemProveField             = "ProveField"
    rsemStrictNotNilExpr       = "StrictNotNil"
    rsemStrictNotNilResult     = "StrictNotNil"
    rsemWarnGcUnsafe           = "GcUnsafe"
    rsemWarnGcUnsafeListing    = "GcUnsafe2"
    rsemProveInit              = "ProveInit"
    rsemUninit                 = "Uninit"
    rsemWarnUnsafeCode         = "UnsafeCode"
    rsemImplicitCstringConvert = "CStringConv"
    rsemHoleEnumConvert        = "HoleEnumConv"
    rsemAnyEnumConvert         = "AnyEnumConv"
    rsemMethodLockMismatch
    rsemUseBase                = "UseBase"
    rsemUnreachableElse        = "UnreachableElse"
    rsemUnreachableCode        = "UnreachableCode"
    rsemInheritFromException   = "InheritFromException"
    rsemPtrRegionIsDeprecated
    rsemTypedReturnDeprecated
    rsemEachIdentIsTuple       = "EachIdentIsTuple"
    rsemResultShadowed         = "ResultShadowed"
    rsemResultUsed             = "ResultUsed"
    rsemGenericMethodsDeprecated
    rsemSuspiciousEnumConv     = "EnumConv"
    rsemUnsafeSetLen           = "UnsafeSetLen"
    rsemUnsafeDefault          = "UnsafeDefault"
    rsemBindDeprecated
    rsemUncollectableRefCycle  =  "CycleCreated"
    rsemParallelWarnCannotProve
    rsemParallelWarnCanProve
    rsemParallelWarnNotDisjoint
    rsemObservableStores       = "ObservableStores"
    rsemCaseTransition         = "CaseTransition"
    rsemUseOfGc                = "GcMem" # last !
    # end

    # trace
    rsemVmStackTrace
    # trace

    # Semantic hints begin
    rsemUserHint = "User" ## `{.hint: .}` pragma encountereed
    rsemLinterReport  = "Name"
    rsemLinterReportUse = "Name"
    rsemHintLibDependency
    rsemXDeclaredButNotUsed = "XDeclaredButNotUsed"
    rsemDuplicateModuleImport = "DuplicateModuleImport"
    rsemXCannotRaiseY = "XCannotRaiseY"
    rsemConvToBaseNotNeeded = "ConvToBaseNotNeeded"
    rsemConvFromXtoItselfNotNeeded = "ConvFromXtoItselfNotNeeded"

    rsemProcessing = "Processing" ## Processing module
    rsemProcessingStmt = "ProcessingStmt" ## Processing toplevel statement

    rsemExprAlwaysX = "ExprAlwaysX" ## Expression always evaluates to "X"
    rsemConditionAlwaysTrue = "CondTrue" ## Condition is always true
    rsemConditionAlwaysFalse = "CondFalse" ## Condition is always false

    rsemPattern = "Pattern" ## Term rewriting pattern has been triggered
    rsemCannotMakeSink ## Argument could not be turned into a sink
                       ## parameter. Generated once in the whole compiler
                       ## `sinkparameter_inference.nim`
    rsemCopiesToSink ## Passing data to the `sink` parameter still copies
                     ## due to control flow in the code

    rsemGlobalVar = "GlobalVar" ## Track global variable declarations?

    rsemEffectsListingHint
    rsemExpandMacro = "ExpandMacro" ## Trace macro expansion progress
    rsemExpandArc = "ExpandArc"

    rsemCompilesReport
    rsemNonMatchingCandidates
    rsemUserRaw = "UserRaw" # REVIEW - Used in
    # `semcall.semOverloadedCall()` and `extccomp.getCompileCFileCmd()`.
    # Seems like this one should be removed, it spans multiple compiler
    # subsystems. Can't understand what it is doing.

    rsemExtendedContext = "ExtendedContext" ## Extended contextual
    ## information. Used in `ccgstmts.genStmts()` and
    ## `semexprs.semExprNoType()`
    rsemImplicitObjConv = "ImplicitObjConv"
    # end


    #------------------------  Command report kinds  -------------------------#
    # errors
    rcmdFailedExecution
    # errors end

    # hints
    rcmdCompiling = "CC"
    rcmdLinking = "Link"
    rcmdExecuting = "Exec"
    rcmdRunnableExamplesSuccess
    # hints end


    #----------------------------  Debug reports  ----------------------------#
    rdbgVmExecTraceFull
    rdbgVmExecTraceMinimal
    rdbgVmCodeListing

    rdbgTraceDefined # first ! tracer begin
    rdbgTraceUndefined
    rdbgTraceStart
    rdbgTraceStep
    rdbgTraceLine
    rdbgTraceEnd # last ! tracer end

    rdbgStartingConfRead
    rdbgFinishedConfRead
    rdbgCfgTrace

    rdbgOptionsPush
    rdbgOptionsPop

    #---------------------------  Backend reports  ---------------------------#
    # errors start
    rbackCannotWriteScript ## Cannot write build script to a cache file
    rbackCannotWriteMappingFile ## Canot write module compilation mapping
    ## file to cache directory
    rbackTargetNotSupported ## C compiler does not support requested target
    rbackJsTooCaseTooLarge
    rbackJsUnsupportedClosureIter
    rbackJsonScriptMismatch # ??? used in `extccomp.nim`, TODO figure out
    # what the original mesage was responsible for exactly

    rbackRstCannotOpenFile
    rbackRstExpected
    rbackRstGridTableNotImplemented
    rbackRstMarkdownIllformedTable
    rbackRstNewSectionExpected
    rbackRstGeneralParseError
    rbackRstInvalidDirective
    rbackRstInvalidField
    rbackRstFootnoteMismatch

    rbackCannotProduceAssembly
    # errors end

    # warnings start
    rbackRstTestUnsupported
    rbackRstRedefinitionOfLabel = "RedefinitionOfLabel"
    rbackRstUnknownSubstitution = "UnknownSubstitutionX"
    rbackRstBrokenLink          = "BrokenLink"
    rbackRstUnsupportedLanguage = "LanguageXNotSupported"
    rbackRstUnsupportedField    = "FieldXNotSupported"
    rbackRstRstStyle            =  "warnRstStyle"

    # warnings end

    # hints start
    rbackProducedAssembly
    rbackCompiling = "Compiling"
    rbackLinking = "Link"
    # hints end

  ReportKinds* = set[ReportKind]

const rstWarnings* = {rbackRstTestUnsupported .. rbackRstRstStyle}

type
  ReportLineInfo* = object
    ## Location expressed in terms of a single point in the file
    file*: string
    line*: uint16
    col*: int16

  ReportSeverity* = enum
    rsevDebug = "Debug" ## Internal compiler debug information

    rsevHint = "Hint" ## User-targeted hint
    rsevWarning = "Warning" ## User-targeted warnings
    rsevError = "Error" ## User-targeted error

    rsevFatal = "Fatal"
    rsevTrace = "Trace" ## Additional information about compiler actions -
    ## external commands mostly.

  ReportContextKind* = enum
    sckInstantiationOf
    sckInstantiationFrom


  ReportContext* = object
    location*: TLineInfo ## Report context instantiation
    case kind*: ReportContextKind
      of sckInstantiationOf:
        entry*: PSym ## Instantiated entry symbol

      of sckInstantiationFrom:
        discard

  ReportBase* = object of RootObj
    context*: seq[ReportContext]

    location*: Option[TLineInfo] ## Location associated with report. Some
    ## reports do not have any locations associated with them (most (but
    ## not all, due to `gorge`) of the external command executions, sem
    ## tracing etc). Some reports might have additional associated location
    ## information (view type sealing reasons) - those are handled on the
    ## per-report-kind basis.

    reportInst*: ReportLineInfo ## Information about instantiation location
    ## of the reports - present for all reports in order to track their
    ## origins.

    reportFrom*: ReportLineInfo ## Information about submit location of the
    ## report

type
  LexerReportKind* = range[rlexMalformedUnderscores .. rlexSyntaxesCode]
  LexerReport* = object of ReportBase
    msg*: string
    case kind*: ReportKind
      of rlexLinterReport:
        wanted*: string
        got*: string

      else:
        discard


const
  repLexerKinds*    = {low(LexerReportKind) .. high(LexerReportKind)}
  rlexHintKinds*    = {rlexLineTooLong .. rlexSyntaxesCode}
  rlexWarningKinds* = {rlexDeprecatedOctalPrefix .. rlexDeprecatedOctalPrefix}
  rlexErrorKinds*   = {rlexMalformedUnderscores .. rlexUnclosedComment}

func severity*(rep: LexerReport): ReportSeverity =
  case LexerReportKind(rep.kind):
    of rlexHintKinds: rsevHint
    of rlexErrorKinds: rsevError
    of rlexWarningKinds: rsevWarning

type
  ParserReportKind* = range[rparInvalidIndentation .. rparName]
  ParserReport* = object of ReportBase
    msg*: string
    found*: string
    case kind*: ReportKind
      of rparIdentExpected .. rparUnexpectedToken:
        expected*: seq[string]

      of rparInvalidFilter:
        node*: PNode

      else:
        discard



const
  repParserKinds* = {low(ParserReportKind) .. high(ParserReportKind)}
  rparHintKinds*    = {rparName}
  rparErrorKinds*   = {rparInvalidIndentation .. rparInvalidFilter}
  rparWarningKinds* = {
    rparInconsistentSpacing .. rparPragmaBeforeGenericParameters}

func severity*(parser: ParserReport): ReportSeverity =
  case ParserReportKind(parser.kind):
    of rparHintKinds: rsevHint
    of rparWarningKinds: rsevWarning
    of rparErrorKinds: rsevError

const
  rsemReportTwoSym* = {
    rsemConflictingExportnims,
    rsemBorrowOutlivesSource,
    rsemImmutableBorrowMutation,
    rsemRedefinitionOf,
    rsemInvalidMethodDeclarationOrder, # [s, witness]
    rsemIllegalCallconvCapture, # [symbol, owner]
    rsemDeprecated # [symbol, use-instead]
  }

  rsemReportOneSym* = {
    rsemUnexpectedPragmaInDefinitionOf,
    rsemDoubleCompletionOf,

    rsemIllegalMemoryCapture,
    rsemOverrideSafetyMismatch,
    rsemOverrideLockMismatch
  }

  rsemReportListSym* = {
    rsemAmbiguous,
    rsemAmbiguousIdent,
    rsemObjectRequiresFieldInit,
    rsemObjectRequiresFieldInitNoDefault
  }

  rsemReportCountMismatch* = {
    rsemWrongNumberOfArguments,
    rsemWrongNumberOfGenericParams,
    rsemInvalidOrderInEnum,
    rsemSetTooBig,
    rsemArrayExpectsPositiveRange,
    rsemExpectedLow0Discriminant,
    rsemInvalidOrderInArrayConstructor,
    rsemTypeConversionArgumentMismatch,
    rsemInvalidTupleSubscript,
    rsemExpectedTemplateWithNArgs,
    rsemExpectedParameterForCxxPattern,
    rsemWrongNumberOfQuoteArguments,
    rsemIndexOutOfBounds,
    rsemExpectedHighCappedDiscriminant
  }

type
  SemReportKind* = range[rsemFatalError .. rsemImplicitObjConv]
  SemReportErrorKind* = range[rsemUserError .. rsemWrappedError]

  SemGcUnsafetyKind* = enum
    sgcuCallsUnsafe
    sgcuAccessesGcGlobal
    sgcuIndirectCallVia
    sgcuIndirectCallHere

  SemSideEffectCallKind* = enum
    ssefUsesGlobalState
    ssefCallsSideEffect
    ssefCallsViaHiddenIndirection
    ssefCallsViaIndirection
    ssefParameterMutation

  SemTypeMismatch* = object
    formalTypeKind*: set[TTypeKind]
    actualType*, formalType*: PType
    descriptionStr*: string

  SemCallMismatch* = object
    ## Description of the single candidate mismatch. This type is later
    ## used to construct meaningful type mismatch message, and must contain
    ## all the necessary information to provide meaningful sorting,
    ## collapse and other operations.
    target*: PSym ## Procedure that was tried for an overload resolution
    expression*: PNode ## Full typed expression that was used as a
    ## procedure call
    arg*: int ## Mismatched argument index. This corresponds to the
    ## *expression* subnode index - due to varargs actual *target
    ## parameter* index might differe. See `.formal` field for the actual
    ## target argument symbol.
    targetArg*: PSym ## parameter that mismatches against provided
    ## argument its position can differ from `arg` because of varargs
    diagnostics*: seq[SemReport]
    arguments*: seq[PNode]
    case kind*: MismatchKind
      of kTypeMismatch, kVarNeeded:
        typeMismatch*: SemTypeMismatch ## Argument type mismatch
                                       ## elaboration

      of kPositionalAlreadyGiven, kUnknownNamedParam,
         kAlreadyGiven, kMissingParam:
        ## Parameter name (if used) is stored in the `.targetArg` symbol
        discard

      else:
        discard

  SemSpellCandidate* = object
    dist*: int
    depth*: int
    sym*: PSym
    isLocal*: bool

  SemNilHistory* = object
    ## keep history for each transition
    info*: TLineInfo ## the location
    nilability*: Nilability ## the nilability
    kind*: NilTransition ## what kind of transition was that
    node*: PNode ## the node of the expression


  SemReport* = object of ReportBase
    ast*: PNode
    typ*: PType
    sym*: PSym
    str*: string
    spellingCandidates*: seq[SemSpellCandidate]

    case kind*: ReportKind
      of rsemDuplicateModuleImport:
        previous*: PSym

      of rsemCannotInstantiateWithParameter:
        arguments*: tuple[got, expected: seq[PNode]]

      of rsemUnavailableTypeBound:
        missingTypeBoundElaboration*: tuple[
          anotherRead: Option[TLineInfo],
          tryMakeSinkParam: bool
        ]

      of rsemDuplicateCaseLabel:
        overlappingGroup*: PNode

      of rsemCannotBorrow:
        borrowPair*: tuple[mutatedHere, connectedVia: TLineInfo]

      of rsemXCannotRaiseY:
        raisesList*: PNode

      of rsemUncollectableRefCycle:
        cycleField*: PNode

      of rsemStrictNotNilExpr, rsemStrictNotNilResult:
        nilIssue*: Nilability
        nilHistory*: seq[SemNilHistory]

      of rsemExpectedIdentifierInExpr,
         rsemExpectedOrdinal,
         rsemIdentExpectedInExpr,
         rsemFieldOkButAssignedValueInvalid:
        wrongNode*: PNode

      of rsemWarnGcUnsafeListing, rsemErrGcUnsafeListing:
        gcUnsafeTrace*: tuple[
          isUnsafe: PSym,
          unsafeVia: PSym,
          unsafeRelation: SemGcUnsafetyKind,
        ]

      of rsemHasSideEffects:
        sideEffectTrace*: seq[tuple[
          isUnsafe: PSym,
          unsafeVia: PSym,
          trace: SemSideEffectCallKind,
          location: TLineInfo,
          level: int
        ]]

        sideEffectMutateConnection*: TLineInfo

      of rsemEffectsListingHint:
        effectListing*: tuple[tags, exceptions: seq[PType]]

      of rsemVmStackTrace:
        currentExceptionA*, currentExceptionB*: PNode
        traceReason*: ReportKind
        stacktrace*: seq[tuple[sym: PSym, location: TLineInfo]]

      of rsemReportCountMismatch,
         rsemWrongNumberOfVariables:
        countMismatch*: tuple[expected, got: Int128]

      of rsemInvalidExtern:
        externName*: string

      of rsemWrongIdent:
        expectedIdents*: seq[string]

      of rsemDrnimCannotProveLeq, rsemDrnimCannotPorveGe:
        drnimExpressions*: tuple[a, b: PNode]

      of rsemExprHasNoAddress:
        isUnsafeAddr*: bool

      of rsemUndeclaredIdentifier,
         rsemCallNotAProcOrField,
           :
        potentiallyRecursive*: bool

        explicitCall*: bool ## Whether `rsemCallNotAProcOrField` error was
        ## caused by expression with explicit dot call: `obj.cal()`
        unexpectedCandidate*: seq[PSym] ## Symbols that are syntactically
        ## valid in this context, but semantically are not allowed - for
        ## example `object.iterator()` call outside of the `for` loop.

      of rsemDisjointFields,
         rsemUnsafeRuntimeDiscriminantInit,
         rsemConflictingDiscriminantInit,
         rsemMissingCaseBranches,
         rsemConflictingDiscriminantValues:
        fieldMismatches*: tuple[first, second: seq[PSym]]
        nodes*: seq[PNode]

      of rsemCannotInstantiate:
        ownerSym*: PSym

      of rsemReportTwoSym + rsemReportOneSym + rsemReportListSym:
        symbols*: seq[PSym]

      of rsemExpandMacro, rsemPattern, rsemExpandArc:
        expandedAst*: PNode

      of rsemLockLevelMismatch, rsemMethodLockMismatch:
        anotherMethod*: PSym
        lockMismatch*: tuple[expected, got: string]

      of rsemTypeMismatch,
         rsemSuspiciousEnumConv,
         rsemTypeKindMismatch,
         rsemSemfoldInvalidConversion,
         rsemCannotConvertTypes,
         rsemImplicitObjConv,
         rsemVmCannotCast,
         rsemIllegalConversion,
         rsemConceptInferenceFailed,
         rsemCannotCastTypes,
         rsemGenericTypeExpected,
         rsemCannotBeOfSubtype,
         rsemDifferentTypeForReintroducedSymbol:
        typeMismatch*: seq[SemTypeMismatch]


      of rsemSymbolKindMismatch:
        expectedSymbolKind*: set[TSymKind]

      of rsemTypeNotAllowed:
        allowedType*: tuple[
          allowed: PType,
          actual: PType,
          kind: TSymKind,
          allowedFlags: TTypeAllowedFlags
        ]

      of rsemCallTypeMismatch, rsemNonMatchingCandidates:
        callMismatches*: seq[SemCallMismatch] ## Description of all the
        ## failed candidates.

      of rsemStaticOutOfBounds, rsemVmIndexError:
        indexSpec*: tuple[usedIdx, minIdx, maxIdx: Int128]



      of rsemProcessing:
        processing*: tuple[
          isNimscript: bool,
          importStackLen: int,
          moduleStatus: string,
          fileIdx: FileIndex
        ]

      of rsemLinterReport, rsemLinterReportUse:
        info*: TLineInfo
        linterFail*: tuple[wanted, got: string]

      else:
        discard

const
  repSemKinds* = {low(SemReportKind) .. high(SemReportKind)}
  rsemErrorKinds* = {rsemUserError .. rsemEmptyAsm}
  rsemWarningKinds* = {rsemUserWarning .. rsemUseOfGc}
  rsemHintKinds* = {rsemUserHint .. rsemImplicitObjConv}

  # Separated into standalone set to reuse in the `options.severity`
  # checking - `--styleCheck=error` is set up as a global option.
  repLinterKinds* = {rlexLinterReport, rsemLinterReport, rsemLinterReportUse}

  # `--experimental=strictNotNil` and `{.experimental: "strictNotNil".}`
  repNilcheckKinds* = {rsemStrictNotNilExpr, rsemStrictNotNilResult}

  rsemMultiNamed* = @{
    "Performance": {rsemCopiesToSink, rsemCannotMakeSink},
    "Name": repLinterKinds,
    "Link": {rbackLinking, rcmdLinking},
    "StrictNotNil": {rsemStrictNotNilExpr, rsemStrictNotNilResult}
  }

func severity*(report: SemReport): ReportSeverity =
  case SemReportKind(report.kind):
    of rsemErrorKinds:   result = rsevError
    of rsemWarningKinds: result = rsevWarning
    of rsemHintKinds:    result = rsevHint
    of rsemVmStackTrace: result = rsevTrace
    of rsemFatalError:   result = rsevFatal

proc reportSymbols*(
    kind: ReportKind,
    symbols: seq[PSym],
    typ: PType = nil,
    ast: PNode = nil
  ): SemReport =
  case kind:
    of rsemReportTwoSym: assert symbols.len == 2
    of rsemReportOneSym: assert symbols.len == 1
    of rsemReportListSym: discard
    else: assert false, $kind

  result = SemReport(kind: kind, ast: ast)
  result.symbols = symbols
  result.typ = typ

func reportSem*(kind: ReportKind): SemReport = SemReport(kind: kind)

func reportAst*(
    kind: ReportKind,
    ast: PNode, str: string = "", typ: PType = nil, sym: PSym = nil
  ): SemReport =

  SemReport(kind: kind, ast: ast, str: str, typ: typ, sym: sym)

func reportTyp*(
    kind: ReportKind,
    typ: PType, ast: PNode = nil, sym: PSym = nil, str: string = ""
  ): SemReport =
  SemReport(kind: kind, typ: typ, ast: ast, sym: sym, str: str)

func reportStr*(
    kind: ReportKind,
    str: string, ast: PNode = nil, typ: PType = nil, sym: PSym = nil
  ): SemReport =

  SemReport(kind: kind, ast: ast, str: str, typ: typ, sym: sym)

func reportSym*(
    kind: ReportKind,
    sym: PSym, ast: PNode = nil, str: string = "", typ: PType = nil,
  ): SemReport =

  SemReport(kind: kind, ast: ast, str: str, typ: typ, sym: sym)

template withIt*(expr: untyped, body: untyped): untyped =
  block:
    var it {.inject.} = expr
    body
    it

template tern*(predicate: bool, tBranch: untyped, fBranch: untyped): untyped =
  ## Shorthand for inline if/else. Allows use of conditions in strformat,
  ## simplifies use in expressions. Less picky with formatting
  {.line: instantiationInfo(fullPaths = true).}:
    block:
      if predicate: tBranch else: fBranch


type
  CmdReportKind* = range[rcmdFailedExecution .. rcmdRunnableExamplesSuccess]
  CmdReport* = object of ReportBase
    cmd*: string
    msg*: string
    code*: int
    case kind*: ReportKind
      of rcmdFailedExecution:
        exitOut*, exitErr*: string

      else:
        discard

const
  repCmdKinds* = {low(CmdReportKind) .. high(CmdReportKind)}
  rcmdErrorKinds* = {rcmdFailedExecution}
  rcmdWarningKinds* = default(set[ReportKind])
  rcmdHintKinds* = {rcmdCompiling .. rcmdRunnableExamplesSuccess}

func severity*(report: CmdReport): ReportSeverity =
  case CmdReportKind(report.kind):
    of rcmdHintKinds: rsevHint
    of rcmdWarningKinds: rsevWarning
    of rcmdErrorKinds: rsevError

type
  DebugReportKind* = range[rdbgVmExecTraceFull .. rdbgOptionsPop]

  DebugSemStepDirection* = enum semstepEnter, semstepLeave
  DebugSemStepKind* = enum
    stepNodeToNode
    stepNodeFlagsToNode
    stepNodeTypeToNode
    stepTypeTypeToType
    stepWrongNode
    stepError
    stepTrack


  DebugSemStep* = object
    direction*: DebugSemStepDirection
    level*: int
    name*: string
    node*: PNode
    steppedFrom*: ReportLineInfo
    case kind*: DebugSemStepKind
      of stepNodeToNode, stepTrack, stepWrongNode, stepError:
        discard

      of stepNodeTypeToNode, stepTypeTypeToType:
        typ*: PType
        typ1*: PType

      of stepNodeFlagsToNode:
        flags*: TExprFlags

  DebugVmCodeEntry* = object
    isTarget*: bool
    info*: TLineInfo
    pc*: int
    idx*: int
    case opc*: TOpcode:
      of opcConv, opcCast:
        types*: tuple[tfrom, tto: PType]

      of opcLdConst, opcAsgnConst:
        ast*: PNode

      else:
        discard

    ra*: int
    rb*: int
    rc*: int


  DebugReport* = object of ReportBase
    case kind*: ReportKind
      of rdbgOptionsPush, rdbgOptionsPop:
        optionsNow*: TOptions

      of rdbgVmExecTraceFull:
        vmgenExecFull*: tuple[
          pc: int,
          opc: TOpcode,
          info: TLineInfo,
          ra, rb, rc: TRegisterKind
        ]

      of rdbgTraceStep:
        semstep*: DebugSemStep

      of rdbgStartingConfRead, rdbgFinishedConfRead:
        filename*: string

      of rdbgCfgTrace:
        str*: string

      of rdbgTraceLine, rdbgTraceStart:
        ctraceData*: tuple[level: int, entries: seq[StackTraceEntry]]

      of rdbgVmCodeListing:
        vmgenListing*: tuple[
          sym: PSym,
          ast: PNode,
          entries: seq[DebugVmCodeEntry]
        ]

      of rdbgVmExecTraceMinimal:
        vmgenExecMinimal*: tuple[
          info: TLineInfo,
          opc: TOpcode
        ]

      else:
        discard

const
  repDebugKinds* = {low(DebugReportKind) .. high(DebugReportKind)}

func severity*(report: DebugReport): ReportSeverity =
  rsevDebug

type
  BackendReportKind* = range[rbackCannotWriteScript .. rbackLinking]
  BackendReport* = object of ReportBase
    msg*: string
    usedCompiler*: string
    case kind*: ReportKind
      of rbackCannotWriteScript,
         rbackProducedAssembly,
         rbackCannotWriteMappingFile:
        filename*: string

      of rbackTargetNotSupported:
        requestedTarget*: string

      of rbackJsonScriptMismatch:
        jsonScriptParams*: tuple[
          outputCurrent, output, jsonFile: string]

      else:
        discard

const
  repBackendKinds* = {low(BackendReportKind) .. high(BackendReportKind)}
  rbackErrorKinds* = {rbackCannotWriteScript .. rbackCannotProduceAssembly}
  rbackWarningKinds* = {rbackRstTestUnsupported .. rbackRstRstStyle}
  rbackHintKinds* = {rbackProducedAssembly .. rbackLinking}



func severity*(report: BackendReport): ReportSeverity =
  case BackendReportKind(report.kind):
    of rbackErrorKinds: rsevError
    of rbackHintKinds: rsevHint
    of rbackWarningKinds: rsevWarning

type
  ExternalReportKind* = range[rextUnknownCCompiler .. rextPath]
  ExternalReport* = object of ReportBase
    ## Report about external environment reads, passed configuration
    ## options etc.
    msg*: string

    case kind*: ReportKind
      of rextInvalidHint .. rextInvalidPath:
        cmdlineSwitch*: string ## Switch in processing
        cmdlineProvided*: string ## Value passed to the command-line
        cmdlineAllowed*: seq[string] ## Allowed command-line values
        cmdlineError*: string ## Textual description of the cmdline failure

      of rextUnknownCCompiler:
        knownCompilers*: seq[string]
        passedCompiler*: string

      of rextInvalidPackageName:
        packageName*: string

      of rextPath:
        packagePath*: string

      else:
        discard

const
  repExternalKinds* = {low(ExternalReportKind) .. high(ExternalReportKind)}
  rextErrorKinds* = {rextUnknownCCompiler .. rextInvalidPackageName}
  rextWarningKinds* = {rextDeprecated}
  rextHintKinds* = {rextConf .. rextPath}

func severity*(report: ExternalReport): ReportSeverity =
  case ExternalReportKind(report.kind):
    of rextErrorKinds: rsevError
    of rextWarningKinds: rsevWarning
    of rextHintKinds: rsevHint

type
  InternalReportKind* = range[rintUnknown .. rintEchoMessage]

const
  repInternalKinds*: ReportKinds = {
    low(InternalReportKind) .. high(InternalReportKind)}

  rintFatalKinds* = {rintUnknown .. rintIce} ## Fatal internal compilation
                                             ## reports
  rintErrorKinds* = {rintCannotOpenFile .. rintNotImplemented}
  rintWarningKinds* = {rintWarnCannotOpenFile .. rintWarnFileChanged}
  rintHintKinds* = {rintSource .. rintSuccessX}
  rintDataPassKinds* = {rintStackTrace .. rintEchoMessage}
  rintCliKinds* = {rintCliHelp .. rintCliAdvancedUsage}

type
  UsedBuildParams* = object
    project*: string
    output*: string
    linesCompiled*: int
    mem*: int
    isMaxMem*: bool
    sec*: float
    case isCompilation*: bool
      of true:
        threads*: bool
        backend*: string
        buildMode*: string
        optimize*: string
        gc*: string

      of false:
        discard

  InternalStateDump* = ref object
    version*: string
    nimExe*: string
    prefixdir*: string
    libpath*: string
    projectPath*: string
    definedSymbols*: seq[string]
    libPaths*: seq[string]
    lazyPaths*: seq[string]
    nimbleDir*: string
    outdir*: string
    `out`*: string
    nimcache*: string
    hints*, warnings*: seq[tuple[name: string, enabled: bool]]

  InternalCliData* = object
    ## Information used to construct messages for CLI reports - `--help`,
    ## `--fullhelp`
    version*: string ## Language version
    sourceHash*: string ## Compiler source code git hash
    sourceDate*: string ## Compiler source code date
    boot*: seq[string] ## nim compiler boot flags
    cpu*: TSystemCPU ## Target CPU
    os*: TSystemOS ## Target OS


  InternalReport* = object of ReportBase
    ## Report generated for the internal compiler workings
    msg*: string
    case kind*: ReportKind
      of rintStackTrace:
        trace*: seq[StackTraceEntry] ## Generated stack trace entries

      of rintDumpState:
        stateDump*: InternalStateDump

      of rintAssert:
        expression*: string

      of rintSuccessX:
        buildParams*: UsedBuildParams

      of rintCannotOpenFile .. rintWarnFileChanged:
        file*: string

      of rintListWarnings, rintListHints:
        enabledOptions*: set[ReportKind]

      of rintCliKinds:
        cliData*: InternalCliData

      else:
        discard



func severity*(report: InternalReport): ReportSeverity =
  case InternalReportKind(report.kind):
    of rintFatalKinds:    rsevFatal
    of rintHintKinds:     rsevHint
    of rintWarningKinds:  rsevWarning
    of rintErrorKinds:    rsevError
    of rintDataPassKinds: rsevTrace

const
  repWarningKinds*: ReportKinds =
    rsemWarningKinds +
      rlexWarningKinds +
      rparWarningKinds +
      rbackWarningKinds +
      rextWarningKinds +
      rcmdWarningKinds +
      rintWarningKinds

  repTraceKinds*: ReportKinds = {rsemVmStackTrace, rintStackTrace}

  repHintKinds*: ReportKinds    =
    rsemHintKinds +
      rlexHintKinds +
      rparHintKinds +
      rbackHintKinds +
      rextHintKinds +
      rcmdHintKinds +
      rintHintKinds

  repErrorKinds*: ReportKinds   =
    rsemErrorKinds +
      rlexErrorKinds +
      rparErrorKinds +
      rbackErrorKinds +
      rextErrorKinds +
      rcmdErrorKinds +
      rintErrorKinds

  repFatalKinds*: ReportKinds = rintFatalKinds
  repAllKinds* = {low(ReportKind) .. high(ReportKind)}



type
  ReportTypes* =
    LexerReport    |
    ParserReport   |
    SemReport      |
    CmdReport      |
    DebugReport    |
    InternalReport |
    BackendReport  |
    ExternalReport

  Report* = object
    ## Toplevel wrapper type for the compiler report
    case category*: ReportCategory
      of repLexer:
        lexReport*: LexerReport

      of repParser:
        parserReport*: ParserReport

      of repSem:
        semReport*: SemReport

      of repCmd:
        cmdReport*: CmdReport

      of repDebug:
        debugReport*: DebugReport

      of repInternal:
        internalReport*: InternalReport

      of repBackend:
        backendReport*: BackendReport

      of repExternal:
        externalReport*: ExternalReport

static:
  when false:
    echo(
      "Nimskull compiler outputs ",
      ord(high(ReportKind)),
      " different kinds of diagnostics")


    echo "size of ReportBase     ", sizeof(ReportBase)
    echo "size of LexerReport    ", sizeof(LexerReport)
    echo "size of ParserReport   ", sizeof(ParserReport)
    echo "size of SemReport      ", sizeof(SemReport)
    echo "size of CmdReport      ", sizeof(CmdReport)
    echo "size of DebugReport    ", sizeof(DebugReport)
    echo "size of InternalReport ", sizeof(InternalReport)
    echo "size of BackendReport  ", sizeof(BackendReport)
    echo "size of ExternalReport ", sizeof(ExternalReport)
    echo "size of Report         ", sizeof(Report)
    echo "sem reports      = ", len(repSemKinds)
    echo "lexer reports    = ", len(repLexerKinds)
    echo "parser reports   = ", len(repParserKinds)
    echo "internal reports = ", len(repInternalKinds)

let reportEmpty* = Report(
  category: repInternal,
  internalReport: InternalReport(kind: repNone))


template eachCategory*(report: Report, field: untyped): untyped =
  case report.category:
    of repLexer:    report.lexReport.field
    of repParser:   report.parserReport.field
    of repCmd:      report.cmdReport.field
    of repSem:      report.semReport.field
    of repDebug:    report.debugReport.field
    of repInternal: report.internalReport.field
    of repBackend:  report.backendReport.field
    of repExternal: report.externalReport.field

func kind*(report: Report): ReportKind = eachCategory(report, kind)
func location*(report: Report): Option[TLineInfo] = eachCategory(report, location)
func reportInst*(report: Report): ReportLineInfo = eachCategory(report, reportInst)
func reportFrom*(report: Report): ReportLineInfo = eachCategory(report, reportFrom)

func `reportFrom=`*(report: var Report, loc: ReportLineInfo) =
  case report.category:
    of repLexer:    report.lexReport.reportFrom = loc
    of repParser:   report.parserReport.reportFrom = loc
    of repCmd:      report.cmdReport.reportFrom = loc
    of repSem:      report.semReport.reportFrom = loc
    of repDebug:    report.debugReport.reportFrom = loc
    of repInternal: report.internalReport.reportFrom = loc
    of repBackend:  report.backendReport.reportFrom = loc
    of repExternal: report.externalReport.reportFrom = loc

func category*(kind: ReportKind): ReportCategory =
  case kind:
    of repDebugKinds:    result = repDebug
    of repInternalKinds: result = repInternal
    of repExternalKinds: result = repExternal
    of repCmdKinds:      result = repCmd

    of repLexerKinds:    result = repLexer
    of repParserKinds:   result = repParser
    of repSemKinds:      result = repSem
    of repBackendKinds:  result = repBackend

    of repNone: assert false, "'none' report does not have category"

func severity*(
    report: ReportTypes,
    asError: ReportKinds,
    asWarning: ReportKinds = default(ReportKinds)
  ): ReportSeverity =

  if report.kind in asError:
    rsevError

  elif report.kind in asWarning:
    rsevWarning

  else:
    severity(report)



func severity*(
    report: Report,
    asError: ReportKinds = default(ReportKinds),
    asWarning: ReportKinds = default(ReportKinds)
  ): ReportSeverity =
  ## Return report severity accounting for 'asError' and 'asWarning'
  ## mapping sets.

  if report.kind in asError: rsevError
  elif report.kind in asWarning: rsevWarning
  else:
    case report.category:
      of repLexer:    report.lexReport.severity()
      of repParser:   report.parserReport.severity()
      of repSem:      report.semReport.severity()
      of repCmd:      report.cmdReport.severity()
      of repInternal: report.internalReport.severity()
      of repBackend:  report.backendReport.severity()
      of repDebug:    report.debugReport.severity()
      of repExternal: report.externalReport.severity()

func toReportLineInfo*(iinfo: InstantiationInfo): ReportLineInfo =
  ReportLineInfo(file: iinfo[0], line: uint16(iinfo[1]), col: int16(iinfo[2]))

template calledFromInfo*(): ReportLineInfo =
  let e = getStackTraceEntries()[^2]
  ReportLineInfo(file: $e.filename, line: e.line.uint16)

func isValid*(point: ReportLineInfo): bool =
  0 < point.file.len and point.file != "???"

template reportHere*[R: ReportTypes](report: R): R =
  block:
    var tmp = report
    tmp.reportInsta = toReportLineInfo(
      instantiationInfo(fullPaths = true))

    tmp

func wrap*(rep: sink LexerReport): Report =
  assert rep.kind in repLexerKinds, $rep.kind
  Report(category: repLexer, lexReport: rep)

func wrap*(rep: sink ParserReport): Report =
  assert rep.kind in repParserKinds, $rep.kind
  Report(category: repParser, parserReport: rep)

func wrap*(rep: sink SemReport): Report =
  assert rep.kind in repSemKinds, $rep.kind
  Report(category: repSem, semReport: rep)

func wrap*(rep: sink BackendReport): Report =
  assert rep.kind in repBackendKinds, $rep.kind
  Report(category: repBackend, backendReport: rep)

func wrap*(rep: sink CmdReport): Report =
  assert rep.kind in repCmdKinds, $rep.kind
  Report(category: repCmd, cmdReport: rep)

func wrap*(rep: sink DebugReport): Report =
  assert rep.kind in repDebugKinds, $rep.kind
  Report(category: repDebug, debugreport: rep)

func wrap*(rep: sink InternalReport): Report =
  assert rep.kind in repInternalKinds, $rep.kind
  Report(category: repInternal, internalReport: rep)

func wrap*(rep: sink ExternalReport): Report =
  assert rep.kind in repExternalKinds, $rep.kind
  Report(category: repExternal, externalReport: rep)

func wrap*[R: ReportTypes](rep: sink R, iinfo: InstantiationInfo): Report =
  var tmp = rep
  tmp.reportInst = toReportLineInfo(iinfo)
  return wrap(tmp)


func wrap*[R: ReportTypes](
    rep: sink R, iinfo: ReportLineInfo, point: TLineInfo): Report =
  var tmp = rep
  tmp.reportInst = iinfo
  tmp.location = some point
  return wrap(tmp)

func wrap*[R: ReportTypes](
    rep: sink R, iinfo: InstantiationInfo, point: TLineInfo): Report =
  wrap(rep, toReportLineInfo(iinfo), point)


func wrap*[R: ReportTypes](iinfo: InstantiationInfo, rep: sink R): Report =
  wrap(rep, iinfo)


template wrap*(rep: ReportTypes): Report =
  wrap(rep, toReportLineInfo(instLoc()))

func `$`*(point: ReportLineInfo): string =
  point.file & "(" & $point.line & ", " & $point.col & ")"


type
  ReportList* = object
    ## List of the accumulated reports. Used for various `sem*` reporting
    ## mostly, and in other places where report might be *generated*, but
    ## not guaranteed to be printed out.
    list: seq[Report]

  ReportSet* = object
    ids: PackedSet[uint32]

func incl*(s: var ReportSet, id: ReportId) = s.ids.incl uint32(id)
func contains*(s: var ReportSet, id: ReportId): bool = s.ids.contains uint32(id)

func addReport*(list: var ReportList, report: Report): ReportId =
  ## Add report to the report list
  list.list.add report
  result = ReportId(uint32(list.list.high) + 1)

func addReport*[R: ReportTypes](list: var ReportList, report: R): ReportId =
  addReport(list, wrap(report))


func getReport*(list: ReportList, id: ReportId): Report =
  ## Get report from the report list using it's id
  list.list[int(uint32(id)) - 1]


func actualType*(r: SemReport): PType = r.typeMismatch[0].actualType
func formalType*(r: SemReport): PType = r.typeMismatch[0].formalType
func symstr*(r: SemReport): string = r.sym.name.s
