setUseIc	ast.html#setUseIc,bool	ast: setUseIc(useIc: bool)	
comment	ast.html#comment,PNode	ast: comment(n: PNode): string	
comment=	ast.html#comment=,PNode,string	ast: comment=(n: PNode; a: string)	
OverloadableSyms	ast.html#OverloadableSyms	ast: OverloadableSyms	
skipForDiscardable	ast.html#skipForDiscardable	ast: skipForDiscardable	
GenericTypes	ast.html#GenericTypes	ast: GenericTypes	
StructuralEquivTypes	ast.html#StructuralEquivTypes	ast: StructuralEquivTypes	
ConcreteTypes	ast.html#ConcreteTypes	ast: ConcreteTypes	
IntegralTypes	ast.html#IntegralTypes	ast: IntegralTypes	
ConstantDataTypes	ast.html#ConstantDataTypes	ast: ConstantDataTypes	
NilableTypes	ast.html#NilableTypes	ast: NilableTypes	
PtrLikeKinds	ast.html#PtrLikeKinds	ast: PtrLikeKinds	
PersistentNodeFlags	ast.html#PersistentNodeFlags	ast: PersistentNodeFlags	
namePos	ast.html#namePos	ast: namePos	
patternPos	ast.html#patternPos	ast: patternPos	
genericParamsPos	ast.html#genericParamsPos	ast: genericParamsPos	
paramsPos	ast.html#paramsPos	ast: paramsPos	
pragmasPos	ast.html#pragmasPos	ast: pragmasPos	
miscPos	ast.html#miscPos	ast: miscPos	
bodyPos	ast.html#bodyPos	ast: bodyPos	
resultPos	ast.html#resultPos	ast: resultPos	
dispatcherPos	ast.html#dispatcherPos	ast: dispatcherPos	
wrongNodePos	ast.html#wrongNodePos	ast: wrongNodePos	
errorKindPos	ast.html#errorKindPos	ast: errorKindPos	
compilerInfoPos	ast.html#compilerInfoPos	ast: compilerInfoPos	
firstArgPos	ast.html#firstArgPos	ast: firstArgPos	
nfAllFieldsSet	ast.html#nfAllFieldsSet	ast: nfAllFieldsSet	
nkCallKinds	ast.html#nkCallKinds	ast: nkCallKinds	
nkIdentKinds	ast.html#nkIdentKinds	ast: nkIdentKinds	
nkPragmaCallKinds	ast.html#nkPragmaCallKinds	ast: nkPragmaCallKinds	
nkLiterals	ast.html#nkLiterals	ast: nkLiterals	
nkFloatLiterals	ast.html#nkFloatLiterals	ast: nkFloatLiterals	
nkLambdaKinds	ast.html#nkLambdaKinds	ast: nkLambdaKinds	
declarativeDefs	ast.html#declarativeDefs	ast: declarativeDefs	
routineDefs	ast.html#routineDefs	ast: routineDefs	
procDefs	ast.html#procDefs	ast: procDefs	
callableDefs	ast.html#callableDefs	ast: callableDefs	
nkSymChoices	ast.html#nkSymChoices	ast: nkSymChoices	
nkStrKinds	ast.html#nkStrKinds	ast: nkStrKinds	
skLocalVars	ast.html#skLocalVars	ast: skLocalVars	
skProcKinds	ast.html#skProcKinds	ast: skProcKinds	
defaultOffset	ast.html#defaultOffset	ast: defaultOffset	
nodeKindsProducedByParse	ast.html#nodeKindsProducedByParse	ast: nodeKindsProducedByParse	
getPIdent	ast.html#getPIdent,PNode	ast: getPIdent(a: PNode): PIdent	
getnimblePkg	ast.html#getnimblePkg,PSym	ast: getnimblePkg(a: PSym): PSym	
id	ast.html#id.t,PIdObj	ast: id(a: PIdObj): int	
IdGenerator	ast.html#IdGenerator	ast: IdGenerator	
PackageModuleId	ast.html#PackageModuleId	ast: PackageModuleId	
idGeneratorFromModule	ast.html#idGeneratorFromModule,PSym	ast: idGeneratorFromModule(m: PSym): IdGenerator	
nextSymId	ast.html#nextSymId,IdGenerator	ast: nextSymId(x: IdGenerator): ItemId	
nextTypeId	ast.html#nextTypeId,IdGenerator	ast: nextTypeId(x: IdGenerator): ItemId	
getnimblePkgId	ast.html#getnimblePkgId,PSym	ast: getnimblePkgId(a: PSym): int	
ggDebug	ast.html#ggDebug	ast: ggDebug	
isCallExpr	ast.html#isCallExpr,PNode	ast: isCallExpr(n: PNode): bool	
len	ast.html#len,Indexable	ast: len(n: Indexable): int	
safeLen	ast.html#safeLen,PNode	ast: safeLen(n: PNode): int	
safeArrLen	ast.html#safeArrLen,PNode	ast: safeArrLen(n: PNode): int	
add	ast.html#add,Indexable,Indexable	ast: add(father, son: Indexable)	
addAllowNil	ast.html#addAllowNil,Indexable,Indexable	ast: addAllowNil(father, son: Indexable)	
`[]`	ast.html#[].t,Indexable,int	ast: `[]`(n: Indexable; i: int): Indexable	
`[]=`	ast.html#[]=.t,Indexable,int,Indexable	ast: `[]=`(n: Indexable; i: int; x: Indexable)	
`[]`	ast.html#[].t,Indexable,BackwardsIndex	ast: `[]`(n: Indexable; i: BackwardsIndex): Indexable	
`[]=`	ast.html#[]=.t,Indexable,BackwardsIndex,Indexable	ast: `[]=`(n: Indexable; i: BackwardsIndex; x: Indexable)	
getDeclPragma	ast.html#getDeclPragma,PNode	ast: getDeclPragma(n: PNode): PNode	
newNode	ast.html#newNode,TNodeKind	ast: newNode(kind: TNodeKind): PNode	
newNodeI	ast.html#newNodeI,TNodeKind,TLineInfo	ast: newNodeI(kind: TNodeKind; info: TLineInfo): PNode	
newNodeI	ast.html#newNodeI,TNodeKind,TLineInfo,int	ast: newNodeI(kind: TNodeKind; info: TLineInfo; children: int): PNode	
newNodeIT	ast.html#newNodeIT,TNodeKind,TLineInfo,PType	ast: newNodeIT(kind: TNodeKind; info: TLineInfo; typ: PType): PNode	
newTree	ast.html#newTree,TNodeKind,varargs[PNode]	ast: newTree(kind: TNodeKind; children: varargs[PNode]): PNode	
newTreeI	ast.html#newTreeI,TNodeKind,TLineInfo,varargs[PNode]	ast: newTreeI(kind: TNodeKind; info: TLineInfo; children: varargs[PNode]): PNode	
newTreeIT	ast.html#newTreeIT,TNodeKind,TLineInfo,PType,varargs[PNode]	ast: newTreeIT(kind: TNodeKind; info: TLineInfo; typ: PType; children: varargs[PNode]): PNode	
previouslyInferred	ast.html#previouslyInferred.t,PType	ast: previouslyInferred(t: PType): PType	
newSym	ast.html#newSym,TSymKind,PIdent,ItemId,PSym,TLineInfo,TOptions	ast: newSym(symKind: TSymKind; name: PIdent; id: ItemId; owner: PSym;\n       info: TLineInfo; options: TOptions = {}): PSym	
astdef	ast.html#astdef,PSym	ast: astdef(s: PSym): PNode	
isMetaType	ast.html#isMetaType,PType	ast: isMetaType(t: PType): bool	
isUnresolvedStatic	ast.html#isUnresolvedStatic,PType	ast: isUnresolvedStatic(t: PType): bool	
linkTo	ast.html#linkTo,PType,PSym	ast: linkTo(t: PType; s: PSym): PType	
linkTo	ast.html#linkTo,PSym,PType	ast: linkTo(s: PSym; t: PType): PSym	
fileIdx	ast.html#fileIdx.t,PSym	ast: fileIdx(c: PSym): FileIndex	
filename	ast.html#filename.t,PSym	ast: filename(c: PSym): string	
appendToModule	ast.html#appendToModule,PSym,PNode	ast: appendToModule(m: PSym; n: PNode)	
GrowthFactor	ast.html#GrowthFactor	ast: GrowthFactor	
StartSize	ast.html#StartSize	ast: StartSize	
copyStrTable	ast.html#copyStrTable,TStrTable,TStrTable	ast: copyStrTable(dest: var TStrTable; src: TStrTable)	
copyIdTable	ast.html#copyIdTable,TIdTable,TIdTable	ast: copyIdTable(dest: var TIdTable; src: TIdTable)	
copyObjectSet	ast.html#copyObjectSet,TObjectSet,TObjectSet	ast: copyObjectSet(dest: var TObjectSet; src: TObjectSet)	
discardSons	ast.html#discardSons,PNode	ast: discardSons(father: PNode)	
withInfo	ast.html#withInfo,PNode,TLineInfo	ast: withInfo(n: PNode; info: TLineInfo): PNode	
newIdentNode	ast.html#newIdentNode,PIdent,TLineInfo	ast: newIdentNode(ident: PIdent; info: TLineInfo): PNode	
newSymNode	ast.html#newSymNode,PSym	ast: newSymNode(sym: PSym): PNode	
newSymNode	ast.html#newSymNode,PSym,TLineInfo	ast: newSymNode(sym: PSym; info: TLineInfo): PNode	
newIntNode	ast.html#newIntNode,TNodeKind,BiggestInt	ast: newIntNode(kind: TNodeKind; intVal: BiggestInt): PNode	
newIntNode	ast.html#newIntNode,TNodeKind,Int128	ast: newIntNode(kind: TNodeKind; intVal: Int128): PNode	
lastSon	ast.html#lastSon,Indexable	ast: lastSon(n: Indexable): Indexable	
skipTypes	ast.html#skipTypes,PType,TTypeKinds	ast: skipTypes(t: PType; kinds: TTypeKinds): PType	
skipDistincts	ast.html#skipDistincts,PType	ast: skipDistincts(t: PType): PType	
newIntTypeNode	ast.html#newIntTypeNode,BiggestInt,PType	ast: newIntTypeNode(intVal: BiggestInt; typ: PType): PNode	
newIntTypeNode	ast.html#newIntTypeNode,Int128,PType	ast: newIntTypeNode(intVal: Int128; typ: PType): PNode	
newFloatNode	ast.html#newFloatNode,TNodeKind,BiggestFloat	ast: newFloatNode(kind: TNodeKind; floatVal: BiggestFloat): PNode	
newStrNode	ast.html#newStrNode,TNodeKind,string	ast: newStrNode(kind: TNodeKind; strVal: string): PNode	
newStrNode	ast.html#newStrNode,string,TLineInfo	ast: newStrNode(strVal: string; info: TLineInfo): PNode	
newProcNode	ast.html#newProcNode,TNodeKind,TLineInfo,PNode,PNode,PNode,PNode,PNode,PNode,PNode	ast: newProcNode(kind: TNodeKind; info: TLineInfo; body: PNode;\n            params, name, pattern, genericParams, pragmas, exceptions: PNode): PNode	
UnspecifiedLockLevel	ast.html#UnspecifiedLockLevel	ast: UnspecifiedLockLevel	
MaxLockLevel	ast.html#MaxLockLevel	ast: MaxLockLevel	
UnknownLockLevel	ast.html#UnknownLockLevel	ast: UnknownLockLevel	
AttachedOpToStr	ast.html#AttachedOpToStr	ast: AttachedOpToStr	
`$`	ast.html#$,TLockLevel	ast: `$`(x: TLockLevel): string	
`$`	ast.html#$,PSym	ast: `$`(s: PSym): string	
newType	ast.html#newType,TTypeKind,ItemId,PSym	ast: newType(kind: TTypeKind; id: ItemId; owner: PSym): PType	
newSons	ast.html#newSons,Indexable,int	ast: newSons(father: Indexable; length: int)	
assignType	ast.html#assignType,PType,PType	ast: assignType(dest, src: PType)	
copyType	ast.html#copyType,PType,ItemId,PSym	ast: copyType(t: PType; id: ItemId; owner: PSym): PType	
exactReplica	ast.html#exactReplica,PType	ast: exactReplica(t: PType): PType	
copySym	ast.html#copySym,PSym,ItemId	ast: copySym(s: PSym; id: ItemId): PSym	
createModuleAlias	ast.html#createModuleAlias,PSym,ItemId,PIdent,TLineInfo,TOptions	ast: createModuleAlias(s: PSym; id: ItemId; newIdent: PIdent; info: TLineInfo;\n                  options: TOptions): PSym	
initStrTable	ast.html#initStrTable,TStrTable	ast: initStrTable(x: var TStrTable)	
newStrTable	ast.html#newStrTable	ast: newStrTable(): TStrTable	
initIdTable	ast.html#initIdTable,TIdTable	ast: initIdTable(x: var TIdTable)	
newIdTable	ast.html#newIdTable	ast: newIdTable(): TIdTable	
resetIdTable	ast.html#resetIdTable,TIdTable	ast: resetIdTable(x: var TIdTable)	
initObjectSet	ast.html#initObjectSet,TObjectSet	ast: initObjectSet(x: var TObjectSet)	
initIdNodeTable	ast.html#initIdNodeTable,TIdNodeTable	ast: initIdNodeTable(x: var TIdNodeTable)	
initNodeTable	ast.html#initNodeTable,TNodeTable	ast: initNodeTable(x: var TNodeTable)	
skipTypes	ast.html#skipTypes,PType,TTypeKinds,int	ast: skipTypes(t: PType; kinds: TTypeKinds; maxIters: int): PType	
skipTypesOrNil	ast.html#skipTypesOrNil,PType,TTypeKinds	ast: skipTypesOrNil(t: PType; kinds: TTypeKinds): PType	
isGCedMem	ast.html#isGCedMem,PType	ast: isGCedMem(t: PType): bool	
propagateToOwner	ast.html#propagateToOwner,PType,PType	ast: propagateToOwner(owner, elem: PType; propagateHasAsgn = true)	
rawAddSon	ast.html#rawAddSon,PType,PType	ast: rawAddSon(father, son: PType; propagateHasAsgn = true)	
rawAddSonNoPropagationOfTypeFlags	ast.html#rawAddSonNoPropagationOfTypeFlags,PType,PType	ast: rawAddSonNoPropagationOfTypeFlags(father, son: PType)	
addSonNilAllowed	ast.html#addSonNilAllowed,PNode,PNode	ast: addSonNilAllowed(father, son: PNode)	
delSon	ast.html#delSon,PNode,int	ast: delSon(father: PNode; idx: int)	
copyNode	ast.html#copyNode,PNode	ast: copyNode(src: PNode): PNode	
transitionSonsKind	ast.html#transitionSonsKind,PNode,range[]	ast: transitionSonsKind(n: PNode; kind: range[nkComesFrom .. nkTupleConstr])	
transitionIntKind	ast.html#transitionIntKind,PNode,range[]	ast: transitionIntKind(n: PNode; kind: range[nkCharLit .. nkUInt64Lit])	
transitionNoneToSym	ast.html#transitionNoneToSym,PNode	ast: transitionNoneToSym(n: PNode)	
transitionSymKindCommon	ast.html#transitionSymKindCommon.t,TSymKind	ast: transitionSymKindCommon(k: TSymKind)	
transitionGenericParamToType	ast.html#transitionGenericParamToType,PSym	ast: transitionGenericParamToType(s: PSym)	
transitionRoutineSymKind	ast.html#transitionRoutineSymKind,PSym,range[]	ast: transitionRoutineSymKind(s: PSym; kind: range[skProc .. skTemplate])	
transitionToLet	ast.html#transitionToLet,PSym	ast: transitionToLet(s: PSym)	
shallowCopy	ast.html#shallowCopy,PNode	ast: shallowCopy(src: PNode): PNode	
copyTree	ast.html#copyTree,PNode	ast: copyTree(src: PNode): PNode	
copyTreeWithoutNode	ast.html#copyTreeWithoutNode,PNode,PNode	ast: copyTreeWithoutNode(src, skippedNode: PNode): PNode	
hasSonWith	ast.html#hasSonWith,PNode,TNodeKind	ast: hasSonWith(n: PNode; kind: TNodeKind): bool	
hasNilSon	ast.html#hasNilSon,PNode	ast: hasNilSon(n: PNode): bool	
containsNode	ast.html#containsNode,PNode,TNodeKinds	ast: containsNode(n: PNode; kinds: TNodeKinds): bool	
hasSubnodeWith	ast.html#hasSubnodeWith,PNode,TNodeKind	ast: hasSubnodeWith(n: PNode; kind: TNodeKind): bool	
getInt	ast.html#getInt,PNode	ast: getInt(a: PNode): Int128	
getInt64	ast.html#getInt64,PNode	ast: getInt64(a: PNode): int64	
getFloat	ast.html#getFloat,PNode	ast: getFloat(a: PNode): BiggestFloat	
getStr	ast.html#getStr,PNode	ast: getStr(a: PNode): string	
getStrOrChar	ast.html#getStrOrChar,PNode	ast: getStrOrChar(a: PNode): string	
isGenericParams	ast.html#isGenericParams,PNode	ast: isGenericParams(n: PNode): bool	
isGenericRoutine	ast.html#isGenericRoutine,PNode	ast: isGenericRoutine(n: PNode): bool	
isError	ast.html#isError,PNode	ast: isError(n: PNode): bool	
isError	ast.html#isError,PSym	ast: isError(s: PSym): bool	
isError	ast.html#isError,PType	ast: isError(t: PType): bool	
isErrorLike	ast.html#isErrorLike,PType	ast: isErrorLike(t: PType): bool	
isErrorLike	ast.html#isErrorLike,PSym	ast: isErrorLike(s: PSym): bool	
isErrorLike	ast.html#isErrorLike,PNode	ast: isErrorLike(n: PNode): bool	
isGenericRoutineStrict	ast.html#isGenericRoutineStrict,PSym	ast: isGenericRoutineStrict(s: PSym): bool	
isGenericRoutine	ast.html#isGenericRoutine,PSym	ast: isGenericRoutine(s: PSym): bool	
skipGenericOwner	ast.html#skipGenericOwner,PSym	ast: skipGenericOwner(s: PSym): PSym	
originatingModule	ast.html#originatingModule,PSym	ast: originatingModule(s: PSym): PSym	
isRoutine	ast.html#isRoutine,PSym	ast: isRoutine(s: PSym): bool	
isCompileTimeProc	ast.html#isCompileTimeProc,PSym	ast: isCompileTimeProc(s: PSym): bool	
isRunnableExamples	ast.html#isRunnableExamples,PNode	ast: isRunnableExamples(n: PNode): bool	
requiredParams	ast.html#requiredParams,PSym	ast: requiredParams(s: PSym): int	
hasPattern	ast.html#hasPattern,PSym	ast: hasPattern(s: PSym): bool	
items	ast.html#items.i,PNode	ast: items(n: PNode): PNode	
pairs	ast.html#pairs.i,PNode	ast: pairs(n: PNode): tuple[i: int, n: PNode]	
isAtom	ast.html#isAtom,PNode	ast: isAtom(n: PNode): bool	
isEmptyType	ast.html#isEmptyType,PType	ast: isEmptyType(t: PType): bool	
makeStmtList	ast.html#makeStmtList,PNode	ast: makeStmtList(n: PNode): PNode	
skipStmtList	ast.html#skipStmtList,PNode	ast: skipStmtList(n: PNode): PNode	
toVar	ast.html#toVar,PType,TTypeKind,IdGenerator	ast: toVar(typ: PType; kind: TTypeKind; idgen: IdGenerator): PType	
toRef	ast.html#toRef,PType,IdGenerator	ast: toRef(typ: PType; idgen: IdGenerator): PType	
toObject	ast.html#toObject,PType	ast: toObject(typ: PType): PType	
toObjectFromRefPtrGeneric	ast.html#toObjectFromRefPtrGeneric,PType	ast: toObjectFromRefPtrGeneric(typ: PType): PType	
isImportedException	ast.html#isImportedException,PType,ConfigRef	ast: isImportedException(t: PType; conf: ConfigRef): bool	
isInfixAs	ast.html#isInfixAs,PNode	ast: isInfixAs(n: PNode): bool	
skipColon	ast.html#skipColon,PNode	ast: skipColon(n: PNode): PNode	
findUnresolvedStatic	ast.html#findUnresolvedStatic,PNode	ast: findUnresolvedStatic(n: PNode): PNode	
hasDestructor	ast.html#hasDestructor.t,PType	ast: hasDestructor(t: PType): bool	
incompleteType	ast.html#incompleteType.t,PType	ast: incompleteType(t: PType): bool	
typeCompleted	ast.html#typeCompleted.t,PSym	ast: typeCompleted(s: PSym)	
detailedInfo	ast.html#detailedInfo.t,PSym	ast: detailedInfo(sym: PSym): string	
isInlineIterator	ast.html#isInlineIterator,PType	ast: isInlineIterator(typ: PType): bool	
isClosureIterator	ast.html#isClosureIterator,PType	ast: isClosureIterator(typ: PType): bool	
isClosure	ast.html#isClosure,PType	ast: isClosure(typ: PType): bool	
isSinkParam	ast.html#isSinkParam,PSym	ast: isSinkParam(s: PSym): bool	
isSinkType	ast.html#isSinkType,PType	ast: isSinkType(t: PType): bool	
newProcType	ast.html#newProcType,TLineInfo,ItemId,PSym	ast: newProcType(info: TLineInfo; id: ItemId; owner: PSym): PType	
addParam	ast.html#addParam,PType,PSym	ast: addParam(procType: PType; param: PSym)	
canRaiseConservative	ast.html#canRaiseConservative,PNode	ast: canRaiseConservative(fn: PNode): bool	
canRaise	ast.html#canRaise,PNode	ast: canRaise(fn: PNode): bool	
toHumanStr	ast.html#toHumanStr,TSymKind	ast: toHumanStr(kind: TSymKind): string	
toHumanStr	ast.html#toHumanStr,TTypeKind	ast: toHumanStr(kind: TTypeKind): string	
skipAddr	ast.html#skipAddr,PNode	ast: skipAddr(n: PNode): PNode	
isNewStyleConcept	ast.html#isNewStyleConcept,PNode	ast: isNewStyleConcept(n: PNode): bool	
